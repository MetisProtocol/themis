// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	erc20 "github.com/metis-seq/themis/contracts/erc20"

	themistypes "github.com/metis-seq/themis/types"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
	sequencerset "github.com/metis-seq/themis/contracts/sequencerset"
	stakemanager "github.com/metis-seq/themis/contracts/stakemanager"
	stakinginfo "github.com/metis-seq/themis/contracts/stakinginfo"
)

// IContractCaller is an autogenerated mock type for the IContractCaller type
type IContractCaller struct {
	mock.Mock
}

// ApproveTokens provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *IContractCaller) ApproveTokens(_a0 *big.Int, _a1 common.Address, _a2 common.Address, _a3 *erc20.Erc20) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int, common.Address, common.Address, *erc20.Erc20) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckIfBlocksExist provides a mock function with given fields: end
func (_m *IContractCaller) CheckIfBlocksExist(end uint64) bool {
	ret := _m.Called(end)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(end)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// CurrentAccountStateRoot provides a mock function with given fields: stakingInfoInstance
func (_m *IContractCaller) CurrentAccountStateRoot(stakingInfoInstance *stakinginfo.Stakinginfo) ([32]byte, error) {
	ret := _m.Called(stakingInfoInstance)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*stakinginfo.Stakinginfo) [32]byte); ok {
		r0 = rf(stakingInfoInstance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*stakinginfo.Stakinginfo) error); ok {
		r1 = rf(stakingInfoInstance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CurrentSpanNumber provides a mock function with given fields: _a0
func (_m *IContractCaller) CurrentSpanNumber(_a0 *sequencerset.Sequencerset) *big.Int {
	ret := _m.Called(_a0)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*sequencerset.Sequencerset) *big.Int); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// DecodeSignerUpdateEvent provides a mock function with given fields: _a0, _a1, _a2
func (_m *IContractCaller) DecodeSignerUpdateEvent(_a0 common.Address, _a1 *types.Receipt, _a2 uint64) (*stakinginfo.StakinginfoSignerChange, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *stakinginfo.StakinginfoSignerChange
	if rf, ok := ret.Get(0).(func(common.Address, *types.Receipt, uint64) *stakinginfo.StakinginfoSignerChange); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.StakinginfoSignerChange)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, *types.Receipt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeValidatorExitEvent provides a mock function with given fields: _a0, _a1, _a2
func (_m *IContractCaller) DecodeValidatorExitEvent(_a0 common.Address, _a1 *types.Receipt, _a2 uint64) (*stakinginfo.StakinginfoUnlockInit, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *stakinginfo.StakinginfoUnlockInit
	if rf, ok := ret.Get(0).(func(common.Address, *types.Receipt, uint64) *stakinginfo.StakinginfoUnlockInit); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.StakinginfoUnlockInit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, *types.Receipt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeValidatorJoinEvent provides a mock function with given fields: _a0, _a1, _a2
func (_m *IContractCaller) DecodeValidatorJoinEvent(_a0 common.Address, _a1 *types.Receipt, _a2 uint64) (*stakinginfo.StakinginfoLocked, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *stakinginfo.StakinginfoLocked
	if rf, ok := ret.Get(0).(func(common.Address, *types.Receipt, uint64) *stakinginfo.StakinginfoLocked); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.StakinginfoLocked)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, *types.Receipt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeValidatorStakeUpdateEvent provides a mock function with given fields: _a0, _a1, _a2
func (_m *IContractCaller) DecodeValidatorStakeUpdateEvent(_a0 common.Address, _a1 *types.Receipt, _a2 uint64) (*stakinginfo.StakinginfoLockUpdate, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *stakinginfo.StakinginfoLockUpdate
	if rf, ok := ret.Get(0).(func(common.Address, *types.Receipt, uint64) *stakinginfo.StakinginfoLockUpdate); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.StakinginfoLockUpdate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, *types.Receipt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeBatchSubmitRewardEvent provides a mock function with given fields: _a0, _a1, _a2
func (_m *IContractCaller) DecodeBatchSubmitRewardEvent(_a0 common.Address, _a1 *types.Receipt, _a2 uint64) (*stakinginfo.StakinginfoBatchSubmitReward, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *stakinginfo.StakinginfoBatchSubmitReward
	if rf, ok := ret.Get(0).(func(common.Address, *types.Receipt, uint64) *stakinginfo.StakinginfoBatchSubmitReward); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.StakinginfoBatchSubmitReward)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, *types.Receipt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: address
func (_m *IContractCaller) GetBalance(address common.Address) (*big.Int, error) {
	ret := _m.Called(address)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Address) *big.Int); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockNumberFromTxHash provides a mock function with given fields: _a0
func (_m *IContractCaller) GetBlockNumberFromTxHash(_a0 common.Hash) (*big.Int, error) {
	ret := _m.Called(_a0)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Hash) *big.Int); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfirmedTxReceipt provides a mock function with given fields: _a0, _a1
func (_m *IContractCaller) GetConfirmedTxReceipt(_a0 common.Hash, _a1 uint64) (*types.Receipt, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.Receipt
	if rf, ok := ret.Get(0).(func(common.Hash, uint64) *types.Receipt); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Receipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, uint64) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMainChainBlock provides a mock function with given fields: _a0
func (_m *IContractCaller) GetMainChainBlock(_a0 *big.Int) (*types.Header, error) {
	ret := _m.Called(_a0)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(*big.Int) *types.Header); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMainTxReceipt provides a mock function with given fields: _a0
func (_m *IContractCaller) GetMainTxReceipt(_a0 common.Hash) (*types.Receipt, error) {
	ret := _m.Called(_a0)

	var r0 *types.Receipt
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Receipt); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Receipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMetisChainBlock provides a mock function with given fields: _a0
func (_m *IContractCaller) GetMetisChainBlock(_a0 *big.Int) (*types.Header, error) {
	ret := _m.Called(_a0)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(*big.Int) *types.Header); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMetisTokenInstance provides a mock function with given fields: metisTokenAddress
func (_m *IContractCaller) GetMetisTokenInstance(metisTokenAddress common.Address) (*erc20.Erc20, error) {
	ret := _m.Called(metisTokenAddress)

	var r0 *erc20.Erc20
	if rf, ok := ret.Get(0).(func(common.Address) *erc20.Erc20); ok {
		r0 = rf(metisTokenAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*erc20.Erc20)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(metisTokenAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMetisTxReceipt provides a mock function with given fields: _a0
func (_m *IContractCaller) GetMetisTxReceipt(_a0 common.Hash) (*types.Receipt, error) {
	ret := _m.Called(_a0)

	var r0 *types.Receipt
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Receipt); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Receipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRootHash provides a mock function with given fields: start, end, length
func (_m *IContractCaller) GetRootHash(start uint64, end uint64, length uint64) ([]byte, error) {
	ret := _m.Called(start, end, length)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint64, uint64, uint64) []byte); ok {
		r0 = rf(start, end, length)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, uint64, uint64) error); ok {
		r1 = rf(start, end, length)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSpanDetails provides a mock function with given fields: id, _a1
func (_m *IContractCaller) GetSpanDetails(id *big.Int, _a1 *sequencerset.Sequencerset) (*big.Int, *big.Int, *big.Int, error) {
	ret := _m.Called(id, _a1)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*big.Int, *sequencerset.Sequencerset) *big.Int); ok {
		r0 = rf(id, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 *big.Int
	if rf, ok := ret.Get(1).(func(*big.Int, *sequencerset.Sequencerset) *big.Int); ok {
		r1 = rf(id, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	var r2 *big.Int
	if rf, ok := ret.Get(2).(func(*big.Int, *sequencerset.Sequencerset) *big.Int); ok {
		r2 = rf(id, _a1)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*big.Int)
		}
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(*big.Int, *sequencerset.Sequencerset) error); ok {
		r3 = rf(id, _a1)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetStakeManagerInstance provides a mock function with given fields: stakingManagerAddress
func (_m *IContractCaller) GetStakeManagerInstance(stakingManagerAddress common.Address) (*stakemanager.Stakemanager, error) {
	ret := _m.Called(stakingManagerAddress)

	var r0 *stakemanager.Stakemanager
	if rf, ok := ret.Get(0).(func(common.Address) *stakemanager.Stakemanager); ok {
		r0 = rf(stakingManagerAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakemanager.Stakemanager)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(stakingManagerAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStakingInfoInstance provides a mock function with given fields: stakingInfoAddress
func (_m *IContractCaller) GetStakingInfoInstance(stakingInfoAddress common.Address) (*stakinginfo.Stakinginfo, error) {
	ret := _m.Called(stakingInfoAddress)

	var r0 *stakinginfo.Stakinginfo
	if rf, ok := ret.Get(0).(func(common.Address) *stakinginfo.Stakinginfo); ok {
		r0 = rf(stakingInfoAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stakinginfo.Stakinginfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(stakingInfoAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorInfo provides a mock function with given fields: valID, stakeManagerInstance
func (_m *IContractCaller) GetValidatorInfo(valID themistypes.ValidatorID, stakeManagerInstance *stakemanager.Stakemanager) (themistypes.Validator, error) {
	ret := _m.Called(valID, stakeManagerInstance)

	var r0 themistypes.Validator
	if rf, ok := ret.Get(0).(func(themistypes.ValidatorID, *stakemanager.Stakemanager) themistypes.Validator); ok {
		r0 = rf(valID, stakeManagerInstance)
	} else {
		r0 = ret.Get(0).(themistypes.Validator)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(themistypes.ValidatorID, *stakemanager.Stakemanager) error); ok {
		r1 = rf(valID, stakeManagerInstance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorSetInstance provides a mock function with given fields: validatorSetAddress
func (_m *IContractCaller) GetValidatorSetInstance(validatorSetAddress common.Address) (*sequencerset.Sequencerset, error) {
	ret := _m.Called(validatorSetAddress)

	var r0 *sequencerset.Sequencerset
	if rf, ok := ret.Get(0).(func(common.Address) *sequencerset.Sequencerset); ok {
		r0 = rf(validatorSetAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sequencerset.Sequencerset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(validatorSetAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsTxConfirmed provides a mock function with given fields: _a0, _a1
func (_m *IContractCaller) IsTxConfirmed(_a0 common.Hash, _a1 uint64) bool {
	ret := _m.Called(_a0, _a1)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, uint64) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// StakeFor provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5
func (_m *IContractCaller) StakeFor(_a0 common.Address, _a1 *big.Int, _a2 *big.Int, _a3 bool, _a4 common.Address, _a5 *stakemanager.Stakemanager) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, *big.Int, bool, common.Address, *stakemanager.Stakemanager) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

func (_m *IContractCaller) GetSequencerSetInstance(sequencerSetAddress common.Address) (*sequencerset.Sequencerset, error) {
	ret := _m.Called(sequencerSetAddress)

	var r0 *sequencerset.Sequencerset
	if rf, ok := ret.Get(0).(func(common.Address) *sequencerset.Sequencerset); ok {
		r0 = rf(sequencerSetAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sequencerset.Sequencerset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(sequencerSetAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
